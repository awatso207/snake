<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Snake</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    
    body {
      background: linear-gradient(135deg, #121212, #2a2a2a);
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      overflow: hidden;
    }
    
    .game-container {
      position: relative;
      margin-top: 20px;
    }
    
    canvas {
      background: #111;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.2), 
                  inset 0 0 15px rgba(0, 0, 0, 0.8);
    }
    
    .game-header {
      text-align: center;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
    }
    
    #score {
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 15px;
      border-radius: 20px;
      font-size: 22px;
      margin: 15px 0;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
      display: inline-block;
      transition: transform 0.2s;
    }
    
    .score-increase {
      transform: scale(1.2);
      color: #0f0;
    }
    
    .controls {
      margin-top: 15px;
      background: rgba(0, 0, 0, 0.4);
      padding: 10px 15px;
      border-radius: 10px;
      text-align: center;
      font-size: 14px;
    }

    .game-over, .pause-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 100;
      display: none;
      min-width: 300px;
    }
    
    .game-over {
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
    }
    
    .pause-overlay {
      box-shadow: 0 0 30px rgba(0, 150, 255, 0.6);
    }
    
    .game-over h2, .pause-overlay h2 {
      margin-top: 0;
    }
    
    .game-over h2 {
      color: #ff3333;
    }
    
    .pause-overlay h2 {
      color: #00a7ff;
    }
    
    .high-scores {
      margin: 15px 0;
      text-align: left;
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      border-radius: 5px;
    }
    
    .high-scores h3 {
      text-align: center;
      margin-top: 0;
      color: #ffcc00;
    }
    
    .high-scores ol {
      margin: 5px 0;
      padding-left: 25px;
    }
    
    .name-input {
      display: none;
      margin-top: 15px;
      text-align: center;
    }
    
    .name-input input {
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 5px;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      width: 60px;
      margin-right: 5px;
      text-transform: uppercase;
    }
    
    .name-input button {
      background: linear-gradient(to bottom, #1a1a1a, #000);
      color: #0f0;
      border: 2px solid #0f0;
      border-radius: 5px;
      padding: 5px 10px;
      font-family: 'Orbitron', sans-serif;
      cursor: pointer;
    }
    
    .restart-btn, .clear-scores-btn {
      background: linear-gradient(to bottom, #1a1a1a, #000);
      color: #0f0;
      border: 2px solid #0f0;
      border-radius: 20px;
      padding: 10px 20px;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      cursor: pointer;
      outline: none;
      transition: all 0.3s;
      margin-top: 15px;
    }
    
    .restart-btn:hover, .clear-scores-btn:hover {
      background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
    }
    
    .clear-scores-btn {
      background: linear-gradient(to bottom, #331a1a, #1a0000);
      color: #ff6666;
      border-color: #ff6666;
      font-size: 14px;
      padding: 8px 15px;
      margin-top: 10px;
    }
    
    .clear-scores-btn:hover {
      background: linear-gradient(to bottom, #442a2a, #2a1a1a);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
    }

    .portal-effect {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1 class="game-header">Quantum Snake</h1>
  <div id="score">Score: 0</div>
  <div class="game-container">
    <canvas id="game" width="400" height="400"></canvas>
    <div class="game-over" id="gameOverModal">
      <h2>Game Over</h2>
      <p id="finalScore">Final Score: 0</p>
      <div class="name-input" id="nameInputContainer">
        <p>New High Score! Enter your 3-letter name:</p>
        <input type="text" id="nameInput" maxlength="3" placeholder="YOU" style="text-transform: uppercase;">
        <button id="saveScoreBtn">Save</button>
      </div>
      <div class="high-scores" id="highScoresContainer">
        <h3>High Scores</h3>
        <ol id="highScoresList"></ol>
        <div style="text-align: center;">
          <button class="clear-scores-btn" id="clearScoresBtn">Clear High Scores</button>
        </div>
      </div>
      <button class="restart-btn" id="restartBtn">Play Again</button>
    </div>
    <div class="pause-overlay" id="pauseOverlay">
      <h2>Game Paused</h2>
      <p>Press 'P' to resume</p>
    </div>
  </div>
  <div class="controls">
    Use Arrow Keys to control the snake<br>
    Eat food to grow | Use portals to teleport<br>
    Press 'P' to pause the game
  </div>
  
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');

    // Game settings
    const gridSize = 20;
    const tileCount = canvas.width / gridSize;
    const pauseOverlay = document.getElementById('pauseOverlay');
    const highScoresList = document.getElementById('highScoresList');
    const nameInputContainer = document.getElementById('nameInputContainer');
    const nameInput = document.getElementById('nameInput');
    const saveScoreBtn = document.getElementById('saveScoreBtn');

    // Snake
    let snake = [{x: 10, y: 10}];
    let direction = {x: 0, y: 0};
    let nextDirection = {x: 0, y: 0};
    let food = {x: 5, y: 5};
    let score = 0;
    let portals = [];
    let portalActive = false;
    let gameActive = true;
    let gamePaused = false;
    let portalAnimationAngle = 0;
    let gameLoopInterval;
    
    // Food animation
    let foodPulse = 0;
    let foodPulseDirection = 0.1;

    // Create portal effect element
    function createPortalEffect(x, y, color) {
      const effect = document.createElement('div');
      effect.className = 'portal-effect';
      effect.style.width = '40px';
      effect.style.height = '40px';
      effect.style.left = (x * gridSize - 10) + 'px';
      effect.style.top = (y * gridSize - 10) + 'px';
      effect.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
      document.querySelector('.game-container').appendChild(effect);
      
      // Animate effect
      let size = 1;
      const anim = setInterval(() => {
        size += 0.2;
        effect.style.transform = `scale(${size})`;
        effect.style.opacity = Math.max(0, 1 - size/5);
        
        if (size > 5) {
          clearInterval(anim);
          effect.remove();
        }
      }, 20);
    }

    // Place portals
    function placePortals() {
      // Two portals, not on snake or food
      portals = [];
      while (portals.length < 2) {
        let px = Math.floor(Math.random() * tileCount);
        let py = Math.floor(Math.random() * tileCount);
        if (
          !snake.some(s => s.x === px && s.y === py) &&
          !(food.x === px && food.y === py) &&
          !portals.some(p => p.x === px && p.y === py)
        ) {
          portals.push({x: px, y: py});
          createPortalEffect(px, py, '#00f');
        }
      }
      portalActive = true;
    }

    // Place food
    function placeFood() {
      let fx, fy;
      do {
        fx = Math.floor(Math.random() * tileCount);
        fy = Math.floor(Math.random() * tileCount);
      } while (
        snake.some(s => s.x === fx && s.y === fy) ||
        portals.some(p => p.x === fx && p.y === fy)
      );
      food = {x: fx, y: fy};
      
      // Add spawn effect for food
      createPortalEffect(fx, fy, '#f00');
    }

    // Update score with animation
    function updateScore() {
      scoreEl.textContent = 'Score: ' + score;
      scoreEl.classList.add('score-increase');
      setTimeout(() => {
        scoreEl.classList.remove('score-increase');
      }, 300);
    }

    // Draw everything
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }

      // Draw snake
      snake.forEach((s, i) => {
        // Snake body gradient
        const gradSize = gridSize - 2;
        const isHead = i === 0;
        
        // Create gradient
        const grad = ctx.createRadialGradient(
          s.x * gridSize + gridSize/2, 
          s.y * gridSize + gridSize/2,
          1,
          s.x * gridSize + gridSize/2, 
          s.y * gridSize + gridSize/2, 
          gradSize
        );
        
        if (isHead) {
          grad.addColorStop(0, '#7fff7f');
          grad.addColorStop(1, '#008800');
        } else {
          grad.addColorStop(0, '#3faf3f');
          grad.addColorStop(1, '#006600');
        }
        
        ctx.fillStyle = grad;
        
        // Draw rounded rectangle for snake segments
        const radius = 4;
        ctx.beginPath();
        ctx.moveTo(s.x * gridSize + radius, s.y * gridSize);
        ctx.arcTo((s.x + 1) * gridSize - 2, s.y * gridSize, (s.x + 1) * gridSize - 2, s.y * gridSize + radius, radius);
        ctx.arcTo((s.x + 1) * gridSize - 2, (s.y + 1) * gridSize - 2, (s.x + 1) * gridSize - radius, (s.y + 1) * gridSize - 2, radius);
        ctx.arcTo(s.x * gridSize, (s.y + 1) * gridSize - 2, s.x * gridSize, (s.y + 1) * gridSize - radius, radius);
        ctx.arcTo(s.x * gridSize, s.y * gridSize, s.x * gridSize + radius, s.y * gridSize, radius);
        ctx.closePath();
        ctx.fill();
        
        // Add eyes for the head
        if (isHead) {
          ctx.fillStyle = '#000';
          
          // Position eyes based on direction
          let eyeOffsetX1, eyeOffsetY1, eyeOffsetX2, eyeOffsetY2;
          
          if (direction.x === 1) { // Right
            eyeOffsetX1 = eyeOffsetX2 = 14;
            eyeOffsetY1 = 6;
            eyeOffsetY2 = 14;
          } else if (direction.x === -1) { // Left
            eyeOffsetX1 = eyeOffsetX2 = 6;
            eyeOffsetY1 = 6;
            eyeOffsetY2 = 14;
          } else if (direction.y === 1) { // Down
            eyeOffsetX1 = 6;
            eyeOffsetX2 = 14;
            eyeOffsetY1 = eyeOffsetY2 = 14;
          } else { // Up or default
            eyeOffsetX1 = 6;
            eyeOffsetX2 = 14;
            eyeOffsetY1 = eyeOffsetY2 = 6;
          }
          
          ctx.beginPath();
          ctx.arc(s.x * gridSize + eyeOffsetX1, s.y * gridSize + eyeOffsetY1, 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(s.x * gridSize + eyeOffsetX2, s.y * gridSize + eyeOffsetY2, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Draw food with pulsing effect
      foodPulse += foodPulseDirection;
      if (foodPulse > 1 || foodPulse < 0) {
        foodPulseDirection *= -1;
      }
      
      const outerRadius = gridSize/2 + 2 * foodPulse;
      const foodGrad = ctx.createRadialGradient(
        food.x * gridSize + gridSize/2, 
        food.y * gridSize + gridSize/2, 
        0,
        food.x * gridSize + gridSize/2, 
        food.y * gridSize + gridSize/2, 
        outerRadius
      );
      
      foodGrad.addColorStop(0, '#ff5555');
      foodGrad.addColorStop(0.7, '#ff0000');
      foodGrad.addColorStop(1, '#cc0000');
      
      ctx.fillStyle = foodGrad;
      ctx.beginPath();
      ctx.arc(
        food.x * gridSize + gridSize/2,
        food.y * gridSize + gridSize/2,
        gridSize/2 - 1,
        0, Math.PI * 2
      );
      ctx.fill();
      
      // Add apple stem
      ctx.fillStyle = '#006400';
      ctx.fillRect(
        food.x * gridSize + gridSize/2 - 1,
        food.y * gridSize + 2,
        2,
        4
      );

      // Draw portals
      if (portalActive) {
        // Animate portals
        portalAnimationAngle += 0.05;
        
        portals.forEach((p, i) => {
          const portalColor = i === 0 ? '#4444ff' : '#8844ff';
          const glowColor = i === 0 ? '#0000ff' : '#6600ff';
          
          // Portal glow
          ctx.shadowBlur = 15;
          ctx.shadowColor = glowColor;
          
          // Main portal circle
          const portalGrad = ctx.createRadialGradient(
            p.x * gridSize + gridSize/2,
            p.y * gridSize + gridSize/2,
            1,
            p.x * gridSize + gridSize/2,
            p.y * gridSize + gridSize/2,
            gridSize/2
          );
          
          portalGrad.addColorStop(0, '#ffffff');
          portalGrad.addColorStop(0.3, portalColor);
          portalGrad.addColorStop(1, '#000066');
          
          ctx.fillStyle = portalGrad;
          ctx.beginPath();
          ctx.arc(
            p.x * gridSize + gridSize/2,
            p.y * gridSize + gridSize/2,
            gridSize/2 - 2,
            0, Math.PI * 2
          );
          ctx.fill();
          
          // Portal rings
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.lineWidth = 1;
          
          for (let r = 0; r < 3; r++) {
            ctx.beginPath();
            ctx.ellipse(
              p.x * gridSize + gridSize/2,
              p.y * gridSize + gridSize/2,
              gridSize/2 - 4,
              (gridSize/2 - 4) * Math.abs(Math.cos(portalAnimationAngle + r * Math.PI/3)),
              portalAnimationAngle + r * Math.PI/6,
              0, Math.PI * 2
            );
            ctx.stroke();
          }
          
          // Reset shadow
          ctx.shadowBlur = 0;
        });
      }
    }

    // High Score System
    // Clear existing high scores (for debugging)
    function clearHighScores() {
      localStorage.removeItem('snakeHighScores');
      displayHighScores();
    }
    
    function isHighScore(newScore) {
      const highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
      
      if (highScores.length === 0) return true;
      if (highScores.length < 5) return true;
      // Check if new score is higher than the lowest recorded score
      return newScore > highScores[highScores.length - 1].score;
    }
    
    function addHighScore(newScore, playerName) {
      let highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
      
      // Add new score with player name
      highScores.push({score: newScore, name: playerName});
      
      // Sort scores in descending order
      highScores.sort((a, b) => b.score - a.score);
      
      // Keep only the top 5
      highScores = highScores.slice(0, 5);
      
      // Save to localStorage
      localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
      
      // Display the updated high scores
      displayHighScores();
    }
    
    function displayHighScores() {
      const highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
      highScoresList.innerHTML = '';
      
      if (highScores.length === 0) {
        highScoresList.innerHTML = '<li>No high scores yet!</li>';
        return;
      }
      
      highScores.forEach(entry => {
        const li = document.createElement('li');
        // Don't default to 'AAA' - if name is missing, show 'Unknown'
        const playerName = entry.name ? entry.name : 'Unknown';
        li.textContent = `${entry.score} points - ${playerName}`;
        highScoresList.appendChild(li);
      });
    }
    
    // Game loop
    function gameLoop() {
      if (!gameActive || gamePaused) return;
      
      // Move snake
      direction = nextDirection;
      if (direction.x !== 0 || direction.y !== 0) {
        const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

        // Wall collision
        if (
          head.x < 0 || head.x >= tileCount ||
          head.y < 0 || head.y >= tileCount
        ) {
          return gameOver();
        }

        // Self collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
          return gameOver();
        }

        // Portal check
        if (portalActive) {
          const portalIdx = portals.findIndex(p => p.x === head.x && p.y === head.y);
          if (portalIdx !== -1) {
            // Teleport to the other portal
            const otherIdx = portalIdx === 0 ? 1 : 0;
            head.x = portals[otherIdx].x;
            head.y = portals[otherIdx].y;
            
            // Portal teleport effect
            createPortalEffect(portals[portalIdx].x, portals[portalIdx].y, '#55f');
            createPortalEffect(portals[otherIdx].x, portals[otherIdx].y, '#55f');
            
            // Portals disappear after use
            portalActive = false;
            // Add score for using portal
            score++;
            updateScore();
          }
        }

        snake.unshift(head);

        // Food check
        if (head.x === food.x && head.y === food.y) {
          score++;
          updateScore();
          placeFood();
          // Place portals every time food is eaten
          placePortals();
        } else {
          snake.pop();
        }
      }

      draw();
    }

    // Game over
    function gameOver() {
      gameActive = false;
      clearInterval(gameLoopInterval);
      
      // Check if it's a high score
      if (isHighScore(score)) {
        nameInputContainer.style.display = 'block';
        nameInput.focus();
      } else {
        // Not a high score, just display the existing ones
        displayHighScores();
      }
      
      // Show game over modal
      finalScoreEl.textContent = 'Final Score: ' + score;
      gameOverModal.style.display = 'block';
    }
    
    // Pause/resume game
    function togglePause() {
      if (!gameActive) return; // Don't pause if game is over
      
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        pauseOverlay.style.display = 'block';
      } else {
        pauseOverlay.style.display = 'none';
      }
    }

    // Restart game
    function restartGame() {
      snake = [{x: 10, y: 10}];
      direction = {x: 0, y: 0};
      nextDirection = {x: 0, y: 0};
      score = 0;
      scoreEl.textContent = 'Score: 0';
      portalActive = false;
      gameActive = true;
      gameOverModal.style.display = 'none';
      nameInputContainer.style.display = 'none';
      nameInput.value = '';
      
      placeFood();
      placePortals();
      draw();
      
      gameLoopInterval = setInterval(gameLoop, 100);
    }

    // Controls
    document.addEventListener('keydown', e => {
      if (!gameActive && e.key === 'Enter') {
        restartGame();
        return;
      }
      
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
      }
      
      if (gamePaused) return; // Don't process movement if paused
      
      switch (e.key) {
        case 'ArrowUp': if (direction.y !== 1) nextDirection = {x: 0, y: -1}; break;
        case 'ArrowDown': if (direction.y !== -1) nextDirection = {x: 0, y: 1}; break;
        case 'ArrowLeft': if (direction.x !== 1) nextDirection = {x: -1, y: 0}; break;
        case 'ArrowRight': if (direction.x !== -1) nextDirection = {x: 1, y: 0}; break;
      }
    });
    
    // Restart button
    restartBtn.addEventListener('click', restartGame);
    
    // Clear high scores button
    const clearScoresBtn = document.getElementById('clearScoresBtn');
    clearScoresBtn.addEventListener('click', clearHighScores);

    // Save score button
    saveScoreBtn.addEventListener('click', () => {
      // Get player name from input, enforce 3 characters, default to "YOU" instead of "AAA"
      let playerName = nameInput.value.toUpperCase().slice(0, 3);
      
      // Ensure name is exactly 3 characters
      while (playerName.length < 3) {
        playerName += ' ';
      }
      
      addHighScore(score, playerName.trim() || 'YOU');
      nameInputContainer.style.display = 'none';
    });
    
    // Handle enter key in name input
    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        saveScoreBtn.click();
      }
    });
    
    // Function to fix any legacy scores that may exist without names
    function fixLegacyScores() {
      const highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
      let needsUpdate = false;
      
      highScores.forEach(entry => {
        if (!entry.name) {
          entry.name = 'YOU';
          needsUpdate = true;
        }
      });
      
      if (needsUpdate) {
        localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
      }
    }
    
    // Load high scores at start
    fixLegacyScores(); // Fix any scores without names
    displayHighScores();
    
    // Set up debug function to reset scores if needed
    window.resetScores = clearHighScores;

    // Start game
    placeFood();
    placePortals();
    draw();
    gameLoopInterval = setInterval(gameLoop, 100);
  </script>
</body>
</html>
